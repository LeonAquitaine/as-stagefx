name: Release

on:
  push:
    branches:
      - main

# Add necessary permissions for creating releases
permissions:
  contents: write

jobs:
  release:
    runs-on: windows-latest  # Changed to Windows for PowerShell

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Check for package-config.json
        id: check_version
        shell: pwsh
        run: |
          if (-not (Test-Path -Path "config/package-config.json")) {
            Write-Error "package-config.json not found!"
            exit 1
          }

      - name: Get version
        id: get_version
        shell: pwsh
        run: |
          $configJson = Get-Content -Path "config/package-config.json" -Raw | ConvertFrom-Json
          $version = $configJson.version
          echo "VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Append
          
      - name: Process release template
        shell: pwsh
        run: |
          # Create a temporary directory for release notes
          New-Item -ItemType Directory -Path "temp/release" -Force
          (Get-Content -Path "docs/template/release.md") -replace '\${VERSION}', "${{ env.VERSION }}" | Set-Content -Path "temp/release/release.md"
          
      - name: Build packages
        shell: pwsh
        run: |
          # Run the package build script
          .\build-packages.ps1
          
      - name: Create tag if it doesn't exist
        id: create_tag
        shell: pwsh
        run: |
          git fetch --tags
          $tagExists = git tag -l | Select-String -Pattern "${{ env.VERSION }}"
          if ($tagExists) {
            Write-Output "Tag ${{ env.VERSION }} already exists."
          } else {
            git tag "${{ env.VERSION }}"
            git push origin "${{ env.VERSION }}"
          }

      - name: Check for existing release
        id: check_release
        uses: actions/github-script@v6
        with:
          script: |
            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: process.env.VERSION
              });
              
              if (release && release.data) {
                console.log(`Existing release found with ID: ${release.data.id}`);
                // Delete the existing release
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.data.id
                });
                console.log('Existing release deleted');
                return 'deleted';
              }
              return 'not_found';
            } catch (error) {
              console.log('No existing release found:', error.message);
              return 'not_found';
            }

      - name: Read package manifest and prepare release
        id: prepare_release
        shell: pwsh
        run: |
          # Read the package manifest
          $manifestPath = "packages/package-manifest.json"
          if (-not (Test-Path -Path $manifestPath)) {
            Write-Error "Package manifest not found at $manifestPath"
            exit 1
          }
            $manifest = Get-Content -Path $manifestPath -Raw | ConvertFrom-Json
          
          # Get all ZIP files in the packages directory
          $zipFileObjects = Get-ChildItem -Path "packages" -Filter "*.zip"
          
          if ($zipFileObjects.Count -eq 0) {
            Write-Error "No ZIP files found in packages directory. Build may have failed."
            exit 1
          }
          
          # Create a list of relative paths for release notes generation and logging
          $relativeZipPaths = @()
          foreach ($zipFileObj in $zipFileObjects) {
            # Construct relative path with forward slashes, e.g., packages/MyArchive.zip
            $relativePath = "packages/$($zipFileObj.Name)" 
            $relativeZipPaths += $relativePath
          }

          Write-Output "Found $($relativeZipPaths.Count) ZIP packages for release (using glob 'packages/*.zip' for upload):"
          foreach ($rPath in $relativeZipPaths) {
            Write-Output "  - $rPath (will be included in release notes)"
          }
          
          # Add package information to release notes
          $releaseNotes = Get-Content -Path "temp/release/release.md" -Raw
          $packageInfo = "`n## Packages`n`n"
          $packageInfo += "This release includes the following packages:\n\n"
          
          foreach ($rPath in $relativeZipPaths) { # Iterate over relative paths
            $zipFileName = Split-Path $rPath -Leaf
            $packageDescription = "" # Default to empty if not found

            # Find the package in the manifest by zipFileName to get its description
            # The $manifest variable is already populated from packages/package-manifest.json
            if ($manifest -and $manifest.packages) {
                foreach ($packageKey in $manifest.packages.PSObject.Properties.Name) {
                    $packageDetail = $manifest.packages.$packageKey
                    # Ensure $packageDetail has zipFile property before accessing
                    if ($packageDetail.PSObject.Properties.Name -contains 'zipFile' -and $packageDetail.zipFile -eq $zipFileName) {
                        if ($packageDetail.PSObject.Properties.Name -contains 'description') {
                            $packageDescription = $packageDetail.description
                        }
                        break # Found the package, no need to search further
                    }
                }
            }
            
            $packageInfo += "* **[$zipFileName](https://github.com/${{ github.repository }}/releases/download/${{ env.VERSION }}/$zipFileName)**"
            if ($packageDescription -and $packageDescription.Trim() -ne "") { # Add description if found and not empty
                $packageInfo += ": $($packageDescription.Trim())" # Trim to remove potential leading/trailing whitespace
            }
            $packageInfo += "\n" # Newline
          }
          
          $packageInfo += "\n### Package Contents\n\n"
          
          foreach ($packageKey in $manifest.packages.PSObject.Properties.Name) {
            $package = $manifest.packages.$packageKey
            $packageDesc = $package.description
            $fileCount = $package.fileCount
            
            $zipFileNameForHeader = "Unknown.zip" # Default
            if ($package.PSObject.Properties.Name -contains 'zipFile' -and $package.zipFile) {
                $zipFileNameForHeader = $package.zipFile
            } elseif ($package.PSObject.Properties.Name -contains 'name' -and $package.name) {
                # Fallback if zipFile property is missing, construct from name (less ideal)
                $zipFileNameForHeader = "$($package.name).zip"
            }

            # Check if package has textures
            $textureInfo = ""
            if ($package.PSObject.Properties.Name -contains "textures" -and $package.textures.fileCount -gt 0) {
              $textureInfo = " + $($package.textures.fileCount) textures"
            }
            
            # New header: Linked ZIP file name
            $packageInfo += "### [$zipFileNameForHeader](https://github.com/${{ github.repository }}/releases/download/${{ env.VERSION }}/$zipFileNameForHeader)`n"
            # Description
            $packageInfo += "$packageDesc`n"
            # Contents
            $packageInfo += "- **Contents**: $fileCount shader files$textureInfo`n`n"
          }
          
          $releaseNotes += $packageInfo
          $releaseNotes | Set-Content -Path "temp/release/release.md"
          
      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.VERSION }}
          body_path: temp/release/release.md
          files: packages/*.zip # Use glob pattern
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}